//---------------------------------------------------------------------------

#include <vcl.h>
#pragma hdrstop
#include "Unit1.h"
#include "Unit2.h"
#include "cmath"

//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TForm2 *Form2;
//---------------------------------------------------------------------------
__fastcall TForm2::TForm2(TComponent* Owner)
	: TForm(Owner)
{
	this->max = 2;
	setlocale( LC_ALL,"Ukrainian" );
}

void TForm2::start_calc(long int count, int order){

ShowMessage(IntToStr((int)count) + " " + IntToStr(order));

  r = order/2;//высчитуем радиус системы
  a = pow(count,(float)1/r);//количество узлов в одном измерении
  d_max = a; //сохраним значение в инт(обрежим дробную часть если она имеется)
  a = a-d_max;// высчитуем разницу между флоатом и интом
  if(a == 0){// если разницы нету то это идельный гиперкуб
	for(int i=0; i<r; i++)
	  number[i] = d_max;// запоминаем и выводим


  }
  else// иначе переходим ко второй части, находим оптимальную структуру
  {
    a = count;
    for(int i=0, b=count; i<r; i++)
	{
      a = pow(b,(float)1/(r-i));//находим количесвто узлов в каждом измерении(при акждом проходе цыкла отнимаем 1 найденое раниие измерение)
      max = 2;//устанавливаем минимальное количесвто узлов 2 для измерения
      for(;max<a;)// цыкл для нахождения двух самых близких чисел из ряда чисел 2^N, одно снизу другое сверху
      {
        min = max;   //запоминаем нижнюю границу
        max = max*2; //выпоняем каждый раз умножение на 2, находим верхнюю
      }
	  number[i] = min;// временно сохраняем результат, и предпологаем что они уже выбраны правильно
      number[i+1] = max;
      min = a-min;// находим растояние от нижнего числа к найденному рание числу а
      max = max-a;// находим растояние от верхнего числа к найденному рание числу а
      if(min>max)//сравниваем растояние, и определяем какое короче
		number[i] = number[i+1];//устанавливаем найденное значение на 1 метосто, 2-е и т.д.
      b = b/number[i];//отнимаем от количесвта узлов найденые уже
      number[i+1] = b;//предпологаем что это последний круг цыкла
    }
  }
  if(flag_pair_value == false){
	  number[r] = 2;
	  number_nodes = number_nodes*2;
	  node_order++;
	  r++;
  }
  //цыкл который упорядочит значения в масиве
  for(int i=1;i<r;i++)
  {
	max = number[i-1];
	if(max>number[i])
    {
	  number[i-1] = number[i];
      number[i] = max;
	  i=0;
	}
  }
};
//---------------------------------------------------------------------------
void TForm2::find_sub_system(long int num, int order){
	   for(int i = 0;;i++){
		order--;
		if(order>3){
		   a = (float)order/2;
		   if(a != (int)a){
			  order--;
			  num = num/2;
			  flag_pair_value = false;
		   }else{
			  flag_pair_value = true;
		   }
           start_calc(num, order);
		   a = number[0];
           for(int i=1; i<r; i++)
              if(number[i]>a)
                 a = number[i];
           if(flag_pair_value){
             d_max = 2*num/a;
		   }else{
             d_max = 4*num/a;
		   }

		   if(d_max == child_bisection){
			  str = IntToStr(number[0]);
			  for(int i=1; i<r; i++)
				 str = str + "*" + IntToStr(number[i]);
			  Form2->Memo1->Lines->Add("");
			  if(!flag_pair_value){
				 order++;
				 num = num*2;
			  }
			  Form2->Memo1->Lines->Add("Під оптимальний варіант конфігурації мережі з порядком вузла d = " + IntToStr(order) + " і розмірами - " +  str + " вузлів");
			  calc_metrik(num, order);
		   }else{
			  if(i == 0){
				 Form2->Memo1->Lines->Add("Під оптимальні варіанти не знайдені.");
              }
              break;
           }

        }else{
           if(i == 0){
			  Form2->Memo1->Lines->Add("Під оптимальні варіанти не знайдені");
           }
           break;
        }
     }
}

 int value = 0; //для сохранения апар витр для заданой конф
//---------------------------------------------------------------------------
void TForm2::calc_metrik(__int64 num, int order){
  if (conf == 0){
	   addCell(0, 0, "_");
	   addCell(0, 1, "Задана");

	   addCell(1, 0, "N");
	   addCell(2, 0, "d");
	   addCell(3, 0, "I");
	   addCell(4, 0, "D");
	   addCell(5, 0, "B");
	   addCell(6, 0, "W");
	   addCell(7, 0, "P");

	   conf++;
	   StringGrid1->RowCount += 1;
  }else {
	   addCell(0, conf+1, "O" + IntToStr(conf));
	   conf++;
	   StringGrid1->RowCount += 1;
  }

   //Розраховуємо кількість зв'язків
   d_max = num*order/2;

   Memo1->Lines->Add("Кількість зв'язків (топологічна вартість) I = " + IntToStr(d_max));

   addCell(N, conf, IntToStr(num));   //кі-сть  вузлів
   addCell(d, conf, IntToStr(order)); //порядок вузлів
   addCell(I, conf, IntToStr(d_max)); //кі-сть зв'язків

   //Розраховуємо максимальний діаметр
   d_max = 0;
   for(int i=0; i<r; i++)
	   d_max = d_max+number[i]/2;

   Memo1->Lines->Add("Максимальний діаметр (максимальна затримка передачі повідомлень між найбільш віддаленими вузлами) D = " + IntToStr(d_max));
   addCell(D, conf, IntToStr(d_max));

   //Розраховуємо ширину бісекції
   a = number[0];
   for(int i=1; i<r; i++)
	  if(number[i]>a)
		 a = number[i];
   d_max = 2*num/a;

   Memo1->Lines->Add("Ширина бісекції (мінімальна кількість зв'язків між двома половинами мережі) B = " + IntToStr(d_max));
   addCell(B, conf, d_max);

   //Розраховуємо апаратурні витрати
   d_max = num * ((7*order) - 3);

   addCell(W, conf, IntToStr(d_max));

  if (conf == 1) { // Для заданої мережі
	  value = d_max;
	  addCell(P, conf, "100%");
  } else{          //усі наступні
	float proc = ((float)(d_max)/(float)(value))*100;
	addCell(P, conf, IntToStr((int)proc) + "%");

	//TODO флоат
  }
}
 boolean upper_optim = false;
//---------------------------------------------------------------------------
void __fastcall TForm2::Button1Click(TObject *Sender){
   //подготовка фронт-енда
	conf = 0;
	for(int i=0;i<StringGrid1->ColCount;i++) //очищення табл
		for(int j=0; j<StringGrid1->RowCount;j++)
			StringGrid1->Cells[i][j] = "";
	//забираем у юзверя значения
	number_nodes = StrToInt(Form2->Edit1->Text);//количество узлов
	node_order   = StrToInt(Form2->Edit2->Text);//порядок узла

	if(number_nodes>pow(2,20) || node_order<4 || node_order>20)
	{   // проверка на граничные параметры
		ShowMessage("Введені вами значення знаходяться поза діапазоном дозволених чисел. Переконайтесь, що введені вами числа виконують дані умови: кількість вузлів не більше числа 2^20, порядок вузла не перевищуе число 20 та не нижче числа 4");
		return;
	}

	//----проверка на пренадлежность к ряду чисел 2^N
	a = number_nodes;
	int count = 0;
	for(;a>=2;){
		a = a/2;
		count++;
	}
	child_bisection = number_nodes/4;
	if(a != 1){
		for(;max<number_nodes;){
			min = max;
			max = max*2;
		}
		CheckBox1->Visible = true;
		CheckBox2->Visible = true;

		CheckBox1->Caption = min;
		CheckBox2->Caption = max;

		ShowMessage("Рекомендується розмір мережі N=2^n! Виберіть одне із двох запропонованчих варіантів.");
		return;
	}//----конец проверки


	//----проверка порядка узла на парность
	a = (float)node_order/2;
	if(a != (int)a){
		node_order--;
		number_nodes = number_nodes/2;
		flag_pair_value = false;
	}else{
		flag_pair_value = true;
	}//----конец проверки


	//----прверка на мин значение количесвта узлов при заданом порядке

	if(number_nodes < pow(4,(node_order/2))){
		ShowMessage("При заданих розмірностях мережі вона не має сенсу! Вам потрібно збільшити кількість вузлів або зменшити їх порядок.");
		return;
	}//----конец проверки
	
	Memo1->Lines->Add("");
	Memo1->Lines->Add("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
	Memo1->Lines->Add("Вхідні параметри - N = " +  Form2->Edit1->Text + " d = " + Form2->Edit2->Text );

	/*
	if(flag_pair_value){
		if(count != node_order)
			start_calc(number_nodes, count);
		else
			Form2->Memo1->Lines->Add("Мережа має гіперкубічну конфігурацію при порядку вузла d = " +  IntToStr(count));
	}else{
		if(count != node_order+1){
			start_calc(number_nodes*2, count);
			node_order--;
			number_nodes = number_nodes/2;
		}else{
			Form2->Memo1->Lines->Add("Мережа має гіперкубічну конфігурацію при порядку вузла d = " +  IntToStr(count));
		}

	}
	*/
	//начало расчетов (расчет - number[], r, a)
	start_calc(number_nodes, node_order);  //если парное то передаем значения as is
										   //если нет - то на 1 порядок меньше

	//----выводим значения на экран
	str = IntToStr(number[0]);
	for(int i=1; i<r; i++)  //формируем строку с конфиг сети
		str = str + "*" + IntToStr(number[i]);

	Memo1->Lines->Add("Знайдена конфігурація мережі - " +  str + " вузлів");

	calc_metrik(number_nodes, node_order);  //выводим значения

	if(Form2->CheckBox5->Checked){
		find_sub_system(number_nodes, node_order);
	}
	if (Form2->CheckBox3->Checked) {
		find_sub_upper(number_nodes, node_order);
	}
}
//---------------------------------------------------------------------------


void TForm2::find_sub_upper(long int num, int order){
//----порядок узлов при гиреркубе
/*	int count = 0;
	a = num;
	for(;a>=2;){
		a = a/2;
		count++;
	}

	child_bisection =  num /4;

	a = (float)count/2;
	if(a != (int)a){
	  count--;
	  num = num/2;
	  flag_pair_value = false;
	}else{
	count++;
	  flag_pair_value = true;
	}
	start_calc(num, count);

	find_sub_system(num, count);



	int d = 0;
	for(int i=0; i<r; i++)
		d += number[i]/2;

	int optimal_b = number[0];
	for(int i=1; i<r; i++)
		if(number[i]>optimal_b)
			optimal_b = number[i];
	optimal_b = (2*num/optimal_b)*2;

	for(int i = 0;;i--){
	}
*/


}









void __fastcall TForm2::CheckBox1Click(TObject *Sender)
{
	if(Form2->CheckBox1->Checked == true)
  {
	Form2->CheckBox2->Enabled = false;
	Form2->Edit1->Text = Form2->CheckBox1->Caption;
  }
  else
	Form2->CheckBox2->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TForm2::CheckBox2Click(TObject *Sender)
{
   if(Form2->CheckBox2->Checked == true)
  {
	Form2->CheckBox1->Enabled = false;
	Form2->Edit1->Text = Form2->CheckBox2->Caption;
  }
  else
	Form2->CheckBox1->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TForm2::Edit1Click(TObject *Sender)
{
	  Form2->Edit1->Text = "";
      Form2->Edit1->Font->Color = clWindowText;

}
//---------------------------------------------------------------------------

void __fastcall TForm2::Edit2Click(TObject *Sender)
{
	  Form2->Edit2->Text = "";
	  Form2->Edit2->Font->Color = clWindowText;
}
//---------------------------------------------------------------------------

void __fastcall TForm2::FormDestroy(TObject *Sender)
{
  Form1->Close();
}
//---------------------------------------------------------------------------

void __fastcall TForm2::FormClose(TObject *Sender, TCloseAction &Action)
{
Form1->Close();
}
//---------------------------------------------------------------------------

void __fastcall TForm2::N2Click(TObject *Sender)
{
	Form1->Close();
    Form2->Close();
}
//---------------------------------------------------------------------------

   void TForm2::makeExcel(){

	WideString str;
    TStringList *sl = new TStringList;
    for(int i = 0 ; i<StringGrid1->RowCount ;++i){
        for(int j = 0; j< StringGrid1->ColCount;++j)

        str +=StringGrid1->Cells[j][i]+ "\t";
        sl->Add(Trim(str));
        str = "\n\r" ;
    SaveDialog1->InitialDir = GetCurrentDir();
	SaveDialog1->DefaultExt = "xls";
	}
	if (SaveDialog1->Execute()){
		sl->SaveToFile(SaveDialog1->FileName);
	}
	delete sl;

	}

void __fastcall TForm2::ExporttoExcel2Click(TObject *Sender)
{
	makeExcel();
}

inline void TForm2::addCell(int row, int column, String ss){
	 Form2->StringGrid1->Cells[row][column] = ss;
}

//---------------------------------------------------------------------------

